<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blazers Command Station</title>
  <link href="https://fonts.cdnfonts.com/css/cascadia-code" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<!-- Load Font Awesome from CDN -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">


 <link rel="stylesheet" href="{{ url_for('static', filename='index.css') }}">

</head>
<body>
  <div id="projectContainer">

    <div id="headerContainer">
      <img src="{{ url_for('static', filename='blazers-logo.png') }}" alt="blazers_logo" class="logo" id="logo"/>
      <h2>Sample Image Analysis Station</h2>
    </div>

    <div id="pictureContainer">
        <div id="album">
          <div id="rock-gallery" class="photoBox">
            
          </div>
        </div>

        <!-- <div id="singlePickout">
            <header>
                  <span id="toggleText" class="toggle-text">Exploration Mode</span>
                  <label title="toggle" class="switch">
                    <input type="checkbox" id="toggleMode">
                    <span class="slider round"></span>
                  </label>
            </header>
          <img id="display-image" src="" alt="Selected Image" />
          <div id="stream">
            
            <video id="webcam" autoplay></video>
          </div>
          <i id="camera-icon" class="fas fa-camera"></i>
          <div id="depth-display">
            
          </div>
          <div class="selectedImage_box">
            <h3 id="display-name">Selected Image Name</h3>
            <button type="submit" id="analyze-btn">Analyze</button>
          </div>
        </div> -->

         <div id="singlePickout">
            <header>
                  <span id="toggleText" class="toggle-text">Exploration Mode</span>
                  <label class="switch">
                    <input type="checkbox" id="toggleMode">
                    <span class="slider round"></span>
                  </label>
            </header>
          <img id="display-image" src="" alt="Selected Image" />
          <div id="stream">
            <video id="webcam" autoplay></video>
            <i id="expand-icon" class="fas fa-expand expand-icon" title="Open Mission Control"></i>
          </div>
          <i id="camera-icon" class="fas fa-camera"></i>
          <div id="depth-display">
            
          </div>
          <div class="selectedImage_box">
            <h3 id="display-name">Selected Image Name</h3>
            <button type="submit" id="analyze-btn">Analyze</button>
          </div>
        </div>
    

        <canvas id="screenshot-canvas" style="display:none;"></canvas>
    </div>

    <div id="analysisContainer">
      <div id="analysisHeader">
        <h6>ANALYSIS CONSOLE</h6>

        <div id="analysis-content">
      
          <div id="status">
              <span id="status-text">RUNNING ANALYSIS. . .</span>
              <div id="progress-container">
                  <div id="progress-bar"></div>
              </div>
          </div>
          <div id="result-message">IMAGE ANALYSIS COMPLETE!</div>
          <!-- <button id="download-report-btn">Download Report</button> -->

      </div>
      
      </div>

      <div id="analysis-section">
        <div id="properties-container" class="analysis-box">
            <!-- Rock properties will be populated here -->
        </div>
        <div id="life-support-container" class="analysis-box">
            <!-- Life support potential will be populated here -->
        </div>
        <div id="analyst-container" class="analysis-box">
            <input type="text" id="image-name-input" placeholder="Change Image Name">
            <textarea id="comment-input" placeholder="Add comments"></textarea>
            <input type="text" id="analyst-name" placeholder="Analyst Name and Designation">
            <button id="save-analysis-btn">Save Analysis</button>

            
        </div>
    </div>

    </div>

      <!-- Rover Control Modal -->
    <div id="roverControlModal" class="rover-control-modal">
      <div class="rover-control-content">
        <div class="rover-control-header">
          <div>
            <span>MARS ROVER MISSION CONTROL STATION</span>
            <div class="connection-indicator">
              <div id="connectionDot" class="status-dot"></div>
              <span id="connectionStatus">DISCONNECTED</span>
            </div>
          </div>
          <span class="close-modal" id="closeModal">&times;</span>
        </div>
        
        <div class="rover-control-body">
          <div class="video-section">
            <div class="rover-video-container">
              <video id="roverVideoFeed" class="rover-video-feed" autoplay></video>
              <div class="video-overlay">
                <div>STATUS: <span id="roverStatus">STANDBY</span></div>
                <div>MISSION: <span id="currentMission">NONE</span></div>
                <div>TARGET: <span id="currentTarget">SCANNING...</span></div>
              </div>
            </div>
            
            <div class="movement-controls">
              <button class="move-btn move-forward" id="moveForward">↑ FORWARD</button>
              <button class="move-btn move-left" id="moveLeft">← LEFT</button>
              <button class="move-btn move-stop" id="moveStop">⏹ STOP</button>
              <button class="move-btn move-right" id="moveRight">→ RIGHT</button>
              <button class="move-btn move-backward" id="moveBackward">↓ BACKWARD</button>
            </div>
          </div>
          
          <div class="control-section">
            <div class="mission-status-panel">
              <div class="status-header">Mission Status</div>
              <div id="statusLog" class="status-log">
                <div><span class="timestamp">00:00:00</span><span class="status-good">SYSTEM INITIALIZED</span></div>
                <div><span class="timestamp">00:00:01</span><span class="status-warning">AWAITING CONNECTION...</span></div>
              </div>
            </div>
            
            <div class="control-buttons">
              <button class="rover-btn" id="startAutonomous">Start Autonomous</button>
              <button class="rover-btn" id="startMission">Begin Mission</button>
              <button class="rover-btn" id="toggleSweep">Toggle Sweep</button>
              <button class="rover-btn" id="resetSequence">Reset Sequence</button>
              <button class="rover-btn" id="abortMission">Abort Mission</button>
              <button class="rover-btn emergency" id="emergencyStop">EMERGENCY STOP</button>
            </div>
            
            <div class="mission-log-panel">
              <div class="status-header">Mission Log</div>
              <textarea id="logInput" class="log-input-area" placeholder="Enter mission log entry..."></textarea>
              <button class="rover-btn" id="addLogEntry" style="width: 100%; margin-top: 10px;">Add Log Entry</button>
              <div id="logEntries" class="log-entries">
                <!-- Log entries will be populated here -->
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import { getAuth, signInWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
  import { getStorage, ref, getDownloadURL, uploadBytes } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-storage.js";
  import { getDatabase, ref as dbRef, child, get, update, onValue } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";
  
  const firebaseConfig = {
    apiKey: "AIzaSyA6c_4j2Zw33NdlP2jSbIp0ySHGSmpluQ8",
    authDomain: "blazers-rovers-sample-database.firebaseapp.com",
    projectId: "blazers-rovers-sample-database",
    storageBucket: "blazers-rovers-sample-database.appspot.com",
    messagingSenderId: "464730486363",
    appId: "1:464730486363:web:78ccfde176cea53e21317e"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const storage = getStorage(app);
  const database = getDatabase(app);

  const analysisSection = document.getElementById('analysis-section');
  analysisSection.style.display = 'none';

  // Rover Control System - COMPLETE INTEGRATION
  class RoverController {
    constructor() {
        this.esp32IP = "192.168.4.1";
        this.websockets = {
            camera: null,
            servo: null,
            command: null
        };
        this.connectionStatus = false;
        this.missionState = {
            autonomous: false,
            sweeping: false,
            currentBalloon: 0
        };
        this.objectDetectionRunning = false;
        this.missionLogs = [];
        this.detectionInterval = null;
        this.init();
    }
    
    init() {
        this.initWebSockets();
        this.startHeartbeat();
        this.initEventListeners();
        this.loadMissionLogsBackup();
    }
    
    initWebSockets() {
        // Camera WebSocket
        const cameraUrl = `ws://${this.esp32IP}/Camera`;
        console.log("Attempting to connect to camera at:", cameraUrl);
        
        this.websockets.camera = new WebSocket(cameraUrl);
        this.websockets.camera.binaryType = 'blob';
        
        this.websockets.camera.onopen = () => {
            console.log("Camera WebSocket connected");
            this.updateConnectionStatus(true);
            this.addStatusLog("Camera feed connected", "good");
        };
        
        this.websockets.camera.onclose = () => {
            console.log("Camera WebSocket disconnected");
            this.updateConnectionStatus(false);
            this.addStatusLog("Camera feed disconnected", "error");
            // Attempt to reconnect after 3 seconds
            setTimeout(() => this.initWebSockets(), 3000);
        };
        
        this.websockets.camera.onerror = (error) => {
            console.error("Camera WebSocket error:", error);
            this.addStatusLog("Camera connection error", "error");
        };
        
        this.websockets.camera.onmessage = (event) => {
            const imageUrl = URL.createObjectURL(event.data);
            const webcam = document.getElementById('webcam');
            const roverVideoFeed = document.getElementById('roverVideoFeed');
            
            if (webcam) webcam.src = imageUrl;
            if (roverVideoFeed) roverVideoFeed.src = imageUrl;
            
            // Send frame to Python backend for object detection if running
            if (this.objectDetectionRunning) {
                this.sendFrameForDetection(event.data);
            }
        };
        
        // Command WebSocket
        const commandUrl = `ws://${this.esp32IP}/Command`;
        console.log("Attempting to connect to command interface at:", commandUrl);
        
        this.websockets.command = new WebSocket(commandUrl);
        
        this.websockets.command.onopen = () => {
            console.log("Command WebSocket connected");
            this.addStatusLog("Command interface ready", "good");
        };
        
        this.websockets.command.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.updateMissionStatus(data);
            } catch (error) {
                console.error("Error parsing command data:", error);
            }
        };
        
        this.websockets.command.onclose = () => {
            console.log("Command WebSocket disconnected");
            this.addStatusLog("Command interface lost", "error");
            setTimeout(() => this.initWebSockets(), 3000);
        };
        
        this.websockets.command.onerror = (error) => {
            console.error("Command WebSocket error:", error);
            this.addStatusLog("Command connection error", "error");
        };
    }
    
    sendCommand(command, value, extraData = {}) {
        if (this.websockets.command && this.websockets.command.readyState === WebSocket.OPEN) {
            const data = {
                command: command,
                value: value,
                timestamp: Date.now(),
                ...extraData
            };
            this.websockets.command.send(JSON.stringify(data));
            console.log('Command sent:', data);
            this.addStatusLog(`Command: ${command} - ${value}`, "good");
        } else {
            this.addStatusLog("Cannot send command - not connected", "error");
            console.warn("Command WebSocket not connected. Command:", command, value);
        }
    }
    
    updateConnectionStatus(connected) {
        this.connectionStatus = connected;
        const dot = document.getElementById('connectionDot');
        const status = document.getElementById('connectionStatus');
        
        if (dot && status) {
            if (connected) {
                dot.classList.add('connected');
                status.textContent = 'CONNECTED';
            } else {
                dot.classList.remove('connected');
                status.textContent = 'DISCONNECTED';
            }
        }
    }
    
    addStatusLog(message, type = "good") {
        const now = new Date();
        const timestamp = now.toTimeString().split(' ')[0];
        const statusLog = document.getElementById('statusLog');
        
        if (statusLog) {
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span class="timestamp">${timestamp}</span><span class="status-${type}">${message.toUpperCase()}</span>`;
            statusLog.appendChild(logEntry);
            statusLog.scrollTop = statusLog.scrollHeight;
            
            // Limit log entries to prevent memory issues
            while (statusLog.children.length > 50) {
                statusLog.removeChild(statusLog.firstChild);
            }
        }
    }
    
    updateMissionStatus(data) {
        this.missionState = { ...this.missionState, ...data };
        
        const roverStatus = document.getElementById('roverStatus');
        const currentMission = document.getElementById('currentMission');
        const currentTarget = document.getElementById('currentTarget');
        
        if (roverStatus && data.missionStatus) {
            roverStatus.textContent = data.missionStatus;
        }
        
        if (currentMission && data.currentBalloon !== undefined) {
            const balloonColors = ["BLACK", "WHITE", "PINK", "YELLOW", "BLUE"];
            const target = data.currentBalloon < balloonColors.length ? 
                balloonColors[data.currentBalloon] : "COMPLETE";
            currentMission.textContent = `BALLOON SEQUENCE - ${target}`;
        }
        
        if (currentTarget && data.targetInfo) {
            currentTarget.textContent = data.targetInfo;
        }
    }
    
    startHeartbeat() {
        setInterval(() => {
            if (this.connectionStatus) {
                this.sendCommand('heartbeat', 'ping');
            }
        }, 10000); // Every 10 seconds
    }
    
    async sendFrameForDetection(frameBlob) {
        try {
            const formData = new FormData();
            formData.append('frame', frameBlob);
            
            const response = await fetch('http://localhost:5000/detect', {
                method: 'POST',
                body: formData,
                timeout: 5000
            });
            
            if (response.ok) {
                const result = await response.json();
                this.processDetectionResult(result);
            } else {
                console.warn('Backend detection failed:', response.statusText);
            }
        } catch (error) {
            console.error('Error sending frame for detection:', error);
            // Don't spam logs with detection errors
            if (Date.now() % 10000 < 1000) { // Log once every 10 seconds
                this.addStatusLog("Detection service unavailable", "warning");
            }
        }
    }
    
    processDetectionResult(result) {
        const depthDisplay = document.getElementById('depth-display');
        const cameraIcon = document.getElementById('camera-icon');
        const currentTarget = document.getElementById('currentTarget');
        
        if (result.objects && result.objects.length > 0) {
            const primaryObject = result.objects[0];
            
            // Update depth display
            if (depthDisplay) {
                const detectionText = `DETECTED: ${primaryObject.class.toUpperCase()} (${(primaryObject.confidence * 100).toFixed(1)}%)`;
                depthDisplay.innerHTML = detectionText;
                depthDisplay.style.color = '#ffaa00';
            }
            
            // Update camera icon
            if (cameraIcon) {
                cameraIcon.style.color = 'red';
            }
            
            // Update mission control target
            if (currentTarget) {
                currentTarget.textContent = `${primaryObject.class.toUpperCase()} DETECTED`;
            }
            
            // Log detection
            this.addStatusLog(`Detected: ${primaryObject.class} (${(primaryObject.confidence * 100).toFixed(1)}%)`, "warning");
            
            // Auto-capture for mission-relevant objects
            const missionObjects = ['hammer', 'tennis_ball', 'traffic_cone', 'balloon'];
            if (missionObjects.some(obj => primaryObject.class.toLowerCase().includes(obj))) {
                this.addStatusLog(`MISSION OBJECT FOUND: ${primaryObject.class}`, "good");
                setTimeout(() => {
                    this.takeScreenshot(primaryObject.class, 1.5);
                }, 1000);
            }
            
            // Process navigation guidance for autonomous mode
            if (result.navigation && this.missionState.autonomous) {
                this.processNavigationGuidance(result.navigation);
            }
            
        } else {
            // No objects detected
            if (depthDisplay) {
                depthDisplay.innerHTML = "SCANNING FOR OBJECTS...";
                depthDisplay.style.color = '#00ff41';
            }
            
            if (cameraIcon) {
                cameraIcon.style.color = 'white';
            }
            
            if (currentTarget) {
                currentTarget.textContent = "SCANNING...";
            }
        }
    }
    
    processNavigationGuidance(guidance) {
        if (!guidance || !this.missionState.autonomous) return;
        
        this.addStatusLog(`Navigation: ${guidance.message}`, "good");
        
        // Auto-execute navigation commands
        switch (guidance.action) {
            case 'move_forward':
                this.sendCommand('move', 'forward');
                setTimeout(() => this.sendCommand('move', 'stop'), 500);
                break;
            case 'turn_left':
                this.sendCommand('move', 'left');
                setTimeout(() => this.sendCommand('move', 'stop'), 300);
                break;
            case 'turn_right':
                this.sendCommand('move', 'right');
                setTimeout(() => this.sendCommand('move', 'stop'), 300);
                break;
            case 'continue_search':
                // Continue current movement pattern
                break;
        }
    }
    
    async takeScreenshot(objectDetected = "Manual", depth = 1.5) {
        const video = document.getElementById('webcam');
        if (!video) {
            this.addStatusLog("No video feed available for screenshot", "error");
            return;
        }
        
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = video.videoWidth || 640;
        canvas.height = video.videoHeight || 480;
        context.drawImage(video, 0, 0, canvas.width, canvas.height);

        canvas.toBlob(async (blob) => {
            if (blob) {
                console.log("Screenshot taken for:", objectDetected);
                this.addStatusLog(`Screenshot captured: ${objectDetected}`, "good");
                
                try {
                    const timestamp = Date.now();
                    const storageRef = ref(storage, `EXPLORATION_SAMPLES/screenshot_${timestamp}.png`);
     
                    await uploadBytes(storageRef, blob);
                    const downloadURL = await getDownloadURL(storageRef);
                    await this.updateDatabaseWithImage(downloadURL, depth, objectDetected);
                    
                } catch (error) {
                    console.error('Error saving screenshot:', error);
                    this.addStatusLog("Screenshot save failed", "error");
                }
            }
        }, 'image/png');
    }
    
    async updateDatabaseWithImage(imageUrl, depth, objectDetected) {
        try {
            const userCredential = await signInWithEmailAndPassword(auth, 'lanre.mohammed23@gmail.com', 'Wilmar.jr7');
            
            const videoImageRef = dbRef(database, 'Samples/');
            const timestamp = Date.now();
            
            await update(child(videoImageRef, timestamp.toString()), {
                object: objectDetected,
                image_name: `exploration_${objectDetected}_${timestamp}`,
                image: `EXPLORATION_SAMPLES/screenshot_${timestamp}.png`,
                timestamp: timestamp,
                depth: depth,
                mode: 'exploration',
                analyst_name: 'Rover System',
                analyst_comment: `Automatically captured during exploration mission. Detected object: ${objectDetected}`
            });

            this.addStatusLog("Image uploaded to database", "good");
            
        } catch (error) {
            console.error('Database update error:', error);
            this.addStatusLog("Database update failed", "error");
        }
    }
    
    startObjectDetection() {
        if (this.objectDetectionRunning) return;
        
        this.objectDetectionRunning = true;
        this.addStatusLog("Object detection started", "good");
        
        // Send frames every 2 seconds to avoid overloading
        this.detectionInterval = setInterval(async () => {
            if (this.objectDetectionRunning) {
                await this.captureAndAnalyzeFrame();
            }
        }, 2000);
    }
    
    stopObjectDetection() {
        this.objectDetectionRunning = false;
        if (this.detectionInterval) {
            clearInterval(this.detectionInterval);
            this.detectionInterval = null;
        }
        this.addStatusLog("Object detection stopped", "warning");
    }
    
    async captureAndAnalyzeFrame() {
        const video = document.getElementById('webcam');
        if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) return;
        
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;
            
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            canvas.toBlob(async (blob) => {
                if (blob) {
                    await this.sendFrameForDetection(blob);
                }
            }, 'image/jpeg', 0.8);
            
        } catch (error) {
            console.error('Error capturing frame:', error);
        }
    }
    
    initEventListeners() {
        // Modal controls
        const expandIcon = document.getElementById('expand-icon');
        const modal = document.getElementById('roverControlModal');
        const closeModal = document.getElementById('closeModal');
        
        if (expandIcon) {
            expandIcon.addEventListener('click', () => {
                if (modal) {
                    modal.style.display = 'block';
                    this.startObjectDetection();
                    this.addStatusLog("Mission control interface opened", "good");
                }
            });
        }
        
        if (closeModal) {
            closeModal.addEventListener('click', () => {
                if (modal) {
                    modal.style.display = 'none';
                    this.stopObjectDetection();
                    this.addStatusLog("Mission control interface closed", "warning");
                }
            });
        }
        
        // Close modal with outside click
        if (modal) {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                    this.stopObjectDetection();
                    this.addStatusLog("Mission control interface closed", "warning");
                }
            });
        }
        
        // Mission control buttons with enhanced functionality
        const buttons = {
            'startAutonomous': () => {
                this.missionState.autonomous = !this.missionState.autonomous;
                this.sendCommand('autonomous', this.missionState.autonomous.toString());
                this.addStatusLog(`Autonomous mode: ${this.missionState.autonomous ? 'ON' : 'OFF'}`, "good");
            },
            'startMission': () => {
                this.sendCommand('startTask', 'true');
                this.addStatusLog("Mission sequence initiated", "good");
            },
            'toggleSweep': () => {
                this.missionState.sweeping = !this.missionState.sweeping;
                this.sendCommand('sweepMode', 'toggle');
                this.addStatusLog(`Sweep mode: ${this.missionState.sweeping ? 'ON' : 'OFF'}`, "good");
            },
            'resetSequence': () => {
                this.sendCommand('resetSequence', 'true');
                this.missionState.currentBalloon = 0;
                this.addStatusLog("Mission sequence reset", "warning");
            },
            'abortMission': () => {
                this.sendCommand('abortMission', 'true');
                this.missionState.autonomous = false;
                this.addStatusLog("Mission aborted", "error");
            },
            'emergencyStop': () => {
                this.sendCommand('emergencyStop', 'true');
                this.missionState.autonomous = false;
                this.addStatusLog("EMERGENCY STOP ACTIVATED", "error");
            }
        };
        
        Object.entries(buttons).forEach(([id, action]) => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.addEventListener('click', action);
            }
        });
        
        // Movement controls with enhanced touch support
        const movementButtons = {
            'moveForward': 'forward',
            'moveBackward': 'backward',
            'moveLeft': 'left',
            'moveRight': 'right',
            'moveStop': 'stop'
        };
        
        Object.entries(movementButtons).forEach(([id, direction]) => {
            const btn = document.getElementById(id);
            if (btn) {
                // Mouse events
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.sendCommand('move', direction);
                });
                btn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    if (direction !== 'stop') this.sendCommand('move', 'stop');
                });
                
                // Touch events for mobile
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.sendCommand('move', direction);
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (direction !== 'stop') this.sendCommand('move', 'stop');
                });
                
                // Prevent context menu on long press
                btn.addEventListener('contextmenu', (e) => e.preventDefault());
            }
        });
        
        // Mission log functionality
        const addLogBtn = document.getElementById('addLogEntry');
        const logInput = document.getElementById('logInput');
        
        if (addLogBtn && logInput) {
            addLogBtn.addEventListener('click', () => {
                const logText = logInput.value.trim();
                if (logText) {
                    this.addMissionLog(logText);
                    logInput.value = '';
                }
            });
            
            logInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    const logText = logInput.value.trim();
                    if (logText) {
                        this.addMissionLog(logText);
                        logInput.value = '';
                    }
                }
            });
        }
    }
    
    addMissionLog(text) {
        const now = new Date();
        const timestamp = now.toTimeString().split(' ')[0];
        
        this.missionLogs.push({
            timestamp: timestamp,
            text: text,
            date: now.toISOString()
        });
        
        const logEntries = document.getElementById('logEntries');
        if (logEntries) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<strong>${timestamp}</strong> - ${text}`;
            logEntries.appendChild(logEntry);
            logEntries.scrollTop = logEntries.scrollHeight;
            
            // Limit log entries
            while (logEntries.children.length > 20) {
                logEntries.removeChild(logEntries.firstChild);
            }
        }
        
        this.addStatusLog("Mission log updated", "good");
        this.saveMissionLogsBackup();
    }
    
    saveMissionLogsBackup() {
        try {
            const backupData = {
                logs: this.missionLogs,
                timestamp: Date.now(),
                missionState: this.missionState
            };
            // Using a simple storage mechanism
            window.missionBackup = backupData;
        } catch (error) {
            console.warn('Could not save mission logs backup:', error);
        }
    }
    
    loadMissionLogsBackup() {
        try {
            if (window.missionBackup) {
                const data = window.missionBackup;
                // Load logs if they're from today
                if (Date.now() - data.timestamp < 24 * 60 * 60 * 1000) {
                    this.missionLogs = data.logs || [];
                    this.missionState = { ...this.missionState, ...data.missionState };
                    
                    // Restore log entries to UI
                    const logEntries = document.getElementById('logEntries');
                    if (logEntries && this.missionLogs.length > 0) {
                        this.missionLogs.forEach(log => {
                            const logEntry = document.createElement('div');
                            logEntry.className = 'log-entry';
                            logEntry.innerHTML = `<strong>${log.timestamp}</strong> - ${log.text}`;
                            logEntries.appendChild(logEntry);
                        });
                        logEntries.scrollTop = logEntries.scrollHeight;
                    }
                }
            }
        } catch (error) {
            console.warn('Could not load mission logs backup:', error);
        }
    }
    
    // Health check for backend services
    async checkBackendHealth() {
        try {
            const response = await fetch('http://localhost:5000/health', {
                method: 'GET'
            });
            
            if (response.ok) {
                const health = await response.json();
                this.addStatusLog("Object detection backend online", "good");
                return true;
            } else {
                this.addStatusLog("Backend health check failed", "warning");
                return false;
            }
        } catch (error) {
            this.addStatusLog("Backend not available - using fallback mode", "warning");
            return false;
        }
    }
}

  // Initialize rover controller
  let roverController;

  document.addEventListener('DOMContentLoaded', function () {
      // Initialize Firebase components first
      const gallery = document.getElementById('rock-gallery');
      const displayImage = document.getElementById('display-image');
      const displayName = document.getElementById('display-name');
    
      // Firebase rock data loading
      async function loadRockData() {
        const auth = getAuth();
        const email = "lanre.mohammed23@gmail.com";
        const password = "Wilmar.jr7";
    
        try {
            const userCredential = await signInWithEmailAndPassword(auth, email, password);
            console.log("User signed in successfully");
    
            const rockDataRef = dbRef(database, 'Samples');
            
            onValue(child(rockDataRef, '/'), (snapshot) => {
                if (snapshot.exists()) {
                    const rockData = snapshot.val();
                    const processedData = {};
                    
                    snapshot.forEach((childSnapshot) => {
                        const key = childSnapshot.key;
                        const data = childSnapshot.val();
                        processedData[key] = data;
                    });
    
                    console.log(processedData);
                    displayRockGallery(processedData);
                } else {
                    console.error("No data available");
                }
            }, (error) => {
                console.error("Error fetching data in real-time:", error);
            });
        } catch (error) {
            console.error("Error during authentication or fetching rock data:", error);
        }
    }

      function displayRockGallery(rockData) {
          const gallery = document.getElementById('rock-gallery');

          Object.values(rockData).forEach(imgData => {
              const card = document.createElement('div');
              card.className = 'image-card';

              const img = document.createElement('img');
              img.setAttribute('loading', 'lazy');

              const placeholder = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjY2NjIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtc2l6ZT0iMTgiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5Mb2FkaW5nLi4uPC90ZXh0Pjwvc3ZnPg==';
              img.src = placeholder;

              // Fetch actual image
              const imgRef = ref(storage, imgData.image);
              getDownloadURL(imgRef).then((url) => {
                  img.src = url;
              }).catch((error) => {
                  console.error("Error fetching image:", error);
              });

              const name = document.createElement('div');
              name.className = 'image-name';
              name.innerText = imgData.image_name;

              card.addEventListener('click', () => {
                  analysisSection.style.display = 'none';
                  displayImage.src = img.src;
                  displayName.innerText = imgData.image_name;
                  storeImageInSession(displayImage.src);
              });

              card.appendChild(img);
              card.appendChild(name);
              gallery.appendChild(card);
          });
      }

      // Initialize rover controller AFTER DOM is loaded
      roverController = new RoverController();
      
      // Mode switching functionality
      const toggleMode = document.getElementById('toggleMode');
      const toggleText = document.getElementById('toggleText');
      const imageBox = document.querySelector('.selectedImage_box');
      const stream = document.getElementById('stream');
      const imageDisplay = document.getElementById('display-image');
      const depthDisplay = document.getElementById('depth-display');
      const cameraIcon = document.getElementById('camera-icon');
      const expandIcon = document.getElementById('expand-icon');

      function switchToExplorationMode() {
          toggleText.innerText = "Exploration Mode";
          depthDisplay.style.display = "flex";
          cameraIcon.style.display = "flex";
          stream.style.display = "flex";
          imageBox.style.display = "none";
          imageDisplay.style.display = "none";
          if (expandIcon) expandIcon.style.display = "block";
          
          // Start object detection when switching to exploration mode
          if (roverController) {
              setTimeout(() => roverController.startObjectDetection(), 1000);
          }
      }

      function switchToAnalysisMode() {
          toggleText.innerText = "Analysis Mode";
          depthDisplay.style.display = "none";
          cameraIcon.style.display = "none";
          stream.style.display = "none";
          imageBox.style.display = "flex";
          imageDisplay.style.display = "flex";
          if (expandIcon) expandIcon.style.display = "none";
          
          // Stop object detection when switching to analysis mode
          if (roverController) {
              roverController.stopObjectDetection();
          }
      }

      if (toggleMode) {
          toggleMode.addEventListener('change', function() {
              if (toggleMode.checked) {
                  switchToExplorationMode();
              } else {
                  switchToAnalysisMode();
              }
          });
      }

      // Initialize in Analysis Mode
      switchToAnalysisMode();
      
      // Enhanced camera icon functionality
      if (cameraIcon) {
          cameraIcon.addEventListener('click', () => {
              if (roverController) {
                  roverController.takeScreenshot("Manual Capture");
              }
          });
      }
      
      // Initialize webcam with fallback
      initializeWebcam();
      
      // Load rock data
      loadRockData();
  });

  // Webcam initialization with ESP32 fallback
  function initializeWebcam() {
      const video = document.getElementById('webcam');
      
      setTimeout(() => {
          if (!roverController.connectionStatus && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
              navigator.mediaDevices.getUserMedia({ video: true })
                  .then(stream => {
                      if (video) {
                          video.srcObject = stream;
                          console.log('Using fallback webcam');
                          if (roverController) {
                              roverController.addStatusLog("Using local webcam as fallback", "warning");
                          }
                      }
                  })
                  .catch(error => {
                      console.error('Error accessing webcam:', error);
                      if (roverController) {
                          roverController.addStatusLog("No camera available", "error");
                      }
                  });
          }
      }, 3000);
  }

  // Teachable Machine integration for analysis mode
  const URL = "https://teachablemachine.withgoogle.com/models/NzfitzWEF/";
  let model, maxPredictions;

  async function loadModel() {
      try {
          const modelURL = URL + "model.json";
          const metadataURL = URL + "metadata.json";
          model = await tmImage.load(modelURL, metadataURL);
          maxPredictions = model.getTotalClasses();
          console.log("Teachable Machine model loaded successfully");
      } catch (error) {
          console.error("Error loading Teachable Machine model:", error);
      }
  }

  async function predictImage(image) {
      if (!model) {
          console.warn("Model not loaded yet");
          return [];
      }
      
      const imgElement = document.createElement('img');
      imgElement.crossOrigin = 'anonymous';
      imgElement.src = image.src;

      await new Promise(resolve => imgElement.onload = resolve);

      const prediction = await model.predict(imgElement);
      return prediction;
  }

  async function analyzeImage() {
      const displayImage = document.getElementById('display-image');
      const base64Image = await convertImageToBase64(displayImage.src);
      
      // Store image data for session
      try {
          const imageData = {
              src: displayImage.src,
              name: document.getElementById('display-name').innerText,
              timestamp: Date.now()
          };
          window.currentImageData = imageData;
      } catch (error) {
          console.error("Error storing image data:", error);
      }

      const predictions = await predictImage(displayImage);

      if (predictions && predictions.length > 0) {
          const highestPrediction = predictions.reduce((prev, current) => 
              (prev.probability > current.probability) ? prev : current);
          const imageName = highestPrediction.className.toLowerCase();
          displayAnalysisData(imageName);
          analysisSection.style.display = 'flex';
      } else {
          console.warn("No predictions available");
          analysisSection.style.display = 'flex';
      }
  }

  async function convertImageToBase64(imageUrl) {
      return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              const base64String = canvas.toDataURL('image/jpeg');
              resolve(base64String);
          };
          img.onerror = reject;
          img.src = imageUrl;
      });
  }

  function storeImageInSession(imageData) {
      try {
          window.selectedImageData = {
              src: imageData,
              timestamp: Date.now()
          };
      } catch (error) {
          console.error("Error storing image in session:", error);
      }
  }

  // Analysis button functionality
  document.addEventListener('DOMContentLoaded', function() {
      const analyzeBtn = document.getElementById('analyze-btn');
      if (analyzeBtn) {
          analyzeBtn.addEventListener('click', function () {
              const status = document.getElementById('status');
              const progressBar = document.getElementById('progress-bar');
              const resultMessage = document.getElementById('result-message');
              const statusText = document.getElementById('status-text');

              status.style.display = 'flex';
              resultMessage.style.display = 'none';
              progressBar.style.width = '0%';

              let progress = 0;
              const interval = setInterval(async () => {
                  progress += 10;
                  progressBar.style.width = progress + '%';

                  if (progress >= 100) {
                      clearInterval(interval);
                      status.style.display = 'none';
                      resultMessage.style.display = 'block';

                      await analyzeImage();
                      analysisSection.style.display = 'flex';

                      // Set up save analysis button
                      setupSaveAnalysisButton();
                  }
              }, 1000);
          });
      }
  });

  function setupSaveAnalysisButton() {
      const saveAnalysisBtn = document.getElementById('save-analysis-btn');
      if (saveAnalysisBtn) {
          // Remove existing event listeners
          const newBtn = saveAnalysisBtn.cloneNode(true);
          saveAnalysisBtn.parentNode.replaceChild(newBtn, saveAnalysisBtn);
          
          newBtn.addEventListener('click', async () => {
              const imageNameInput = document.getElementById('image-name-input').value;
              const commentInput = document.getElementById('comment-input').value;
              const analystName = document.getElementById('analyst-name').value;

              if (imageNameInput && commentInput && analystName) {
                  const updateData = {
                      analyst_name: analystName,
                      analyst_comment: commentInput,
                      image_name: imageNameInput
                  };

                  try {
                      const rockDataRef = dbRef(database, 'Samples');
                      const displayName = document.getElementById('display-name').innerText.toLowerCase();

                      const snapshot = await get(child(rockDataRef, '/'));
                      if (snapshot.exists()) {
                          const rockData = snapshot.val();
                          console.log(rockData);

                          for (const key in rockData) {
                              if (rockData.hasOwnProperty(key)) {
                                  const sample = rockData[key];
                                  if (sample.image_name && sample.image_name.toLowerCase() === displayName) {
                                      await update(child(rockDataRef, key), updateData);
                                      alert("Analysis saved successfully!");
                                      generatePDFReport();
                                      analysisSection.style.display = 'none';
                                      break;
                                  }
                              }
                          }
                      } else {
                          console.error("No data available to update with analyst input");
                      }
                  } catch (error) {
                      console.error("Error saving analysis:", error);
                      alert("Error saving analysis. Please try again.");
                  }
              } else {
                  alert("Please fill out all fields in the Analyst section.");
              }
          });
      }
  }

  function displayAnalysisData(imageName) {
    console.log("Searching for data with image name:", imageName.toLowerCase());
    const datasetRef = dbRef(database, 'Dataset');
    
    get(datasetRef).then(snapshot => {
        if (snapshot.exists()) {
            const dataset = snapshot.val();
            let sample = null;

            for (const key in dataset) {
                if (dataset.hasOwnProperty(key)) {
                    const subdata = dataset[key];
                    if (subdata.type && subdata.type.toLowerCase() === imageName.toLowerCase()) {
                        sample = subdata;
                        break;
                    }
                }
            }

            if (sample) {
                console.log("Sample found:", sample);

                const propertiesContainer = document.getElementById('properties-container');
                if (propertiesContainer) {
                    propertiesContainer.innerHTML = `
                        <h4>ROCK CHARACTERISTICS</h4>
                        <p><strong>Type:</strong> ${sample.type}  |  <strong>Formation Process:</strong> ${sample.formation_process}</p>
                        <p><strong>Description:</strong> ${sample.description}</p>
                        <p><strong>Texture:</strong> ${sample.texture}  |  <strong>Structure:</strong> ${sample.structure}</p>
                        <p><strong>Mineral Composition:</strong> ${sample.mineral_composition ? sample.mineral_composition.join(", ") : "N/A"}</p>
                    `;
                }

                const lifeSupportContainer = document.getElementById('life-support-container');
                if (lifeSupportContainer) {
                    const lifeSupportYesNo = sample.life_support_potential && sample.life_support_potential.percentage >= 50 ? 
                        `<span style="color: lightgreen;">Yes</span>` : `<span style="color: red;">No</span>`;
                    lifeSupportContainer.innerHTML = `
                        <h4>Habitability Assessment</h4>
                        <p><strong>Signs of Water:</strong> ${sample.signs_of_water ? 'Yes' : 'No'}</p>
                        <p><strong>Potential to support life:</strong> ${lifeSupportYesNo}, with a ${sample.life_support_potential ? sample.life_support_potential.percentage : 0}% probability</p>
                        <p><strong>Reason:</strong> ${sample.life_support_potential ? sample.life_support_potential.description : "No data available"}</p>
                    `;
                }
            } else {
                console.log("No matching sample found for the selected image.");
                
                // Show default analysis for unknown samples
                const propertiesContainer = document.getElementById('properties-container');
                if (propertiesContainer) {
                    propertiesContainer.innerHTML = `
                        <h4>ROCK CHARACTERISTICS</h4>
                        <p><strong>Type:</strong> Unknown Sample</p>
                        <p><strong>Description:</strong> Analysis in progress. Manual identification required.</p>
                        <p><strong>Status:</strong> Awaiting detailed geological assessment.</p>
                    `;
                }

                const lifeSupportContainer = document.getElementById('life-support-container');
                if (lifeSupportContainer) {
                    lifeSupportContainer.innerHTML = `
                        <h4>Habitability Assessment</h4>
                        <p><strong>Status:</strong> Preliminary scan required for habitability assessment.</p>
                        <p><strong>Recommendation:</strong> Collect additional samples for detailed analysis.</p>
                    `;
                }
            }
        } else {
            console.log("No data found in the dataset.");
            alert("No data found in the dataset.");
        }
    }).catch(error => {
        console.error("Error fetching dataset data:", error);
    });
  }

  // PDF Report Generation
  function generatePDFReport() {
    const analysisImageSrc = document.getElementById('display-image').src;
    const rockCharacteristics = document.getElementById('properties-container').innerText;
    const habitabilityAssessment = document.getElementById('life-support-container').innerText;
    const analystComment = document.getElementById('comment-input').value;
    const analystName = document.getElementById('analyst-name').value;
    const imageNameInput = document.getElementById('image-name-input').value;
    const logoImageSrc = './Blazers-Logo.png';

    const reportContainer = document.createElement('div');
    reportContainer.className = 'report-container';
    reportContainer.style.cssText = `
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background: white;
        color: black;
    `;

    const letterhead = document.createElement('div');
    letterhead.className = 'letterhead';
    letterhead.style.cssText = `
        display: flex;
        align-items: center;
        margin-bottom: 30px;
        border-bottom: 2px solid #333;
        padding-bottom: 20px;
    `;

    const logoSection = document.createElement('div');
    logoSection.className = 'logo-section';
    const logoImg = document.createElement('img');
    logoImg.src = logoImageSrc;
    logoImg.style.cssText = 'width: 80px; height: 80px; margin-right: 20px;';
    logoSection.appendChild(logoImg);

    const textSection = document.createElement('div');
    textSection.className = 'text-section';
    const title = document.createElement('h1');
    title.innerText = 'Mars Rover Image Analysis Report';
    title.style.cssText = 'margin: 0; font-size: 24px;';
    textSection.appendChild(title);

    letterhead.appendChild(logoSection);
    letterhead.appendChild(textSection);

    // Sample Details section
    const reportSection1 = document.createElement('div');
    reportSection1.className = 'report-section';
    reportSection1.style.cssText = 'margin-bottom: 30px;';
    
    const sampleDetailsTitle = document.createElement('h2');
    sampleDetailsTitle.innerText = 'Sample Details';
    sampleDetailsTitle.style.cssText = 'color: #333; border-bottom: 1px solid #ccc; padding-bottom: 5px;';
    
    const togetherDiv = document.createElement('div');
    togetherDiv.className = 'together';
    togetherDiv.style.cssText = 'display: flex; justify-content: space-between; margin-bottom: 20px;';
    
    const sampleName = document.createElement('p');
    sampleName.innerHTML = `<b>Sample Name: </b> ${imageNameInput}`;
    
    const dateCaptured = document.createElement('p');
    dateCaptured.innerHTML = `<b>Date Captured: </b><span>${new Date().toLocaleDateString()}</span>`;
    
    togetherDiv.appendChild(sampleName);
    togetherDiv.appendChild(dateCaptured);

    const sampleImage = document.createElement('img');
    sampleImage.id = imageNameInput;
    sampleImage.style.cssText = 'max-width: 100%; height: auto; margin: 20px 0;';
    
    const sampleCaption = document.createElement('i');
    sampleCaption.innerText = `Fig.1 ${imageNameInput}_Sample`;
    sampleCaption.style.cssText = 'display: block; text-align: center; margin-bottom: 20px;';

    reportSection1.appendChild(sampleDetailsTitle);
    reportSection1.appendChild(togetherDiv);
    reportSection1.appendChild(sampleImage);
    reportSection1.appendChild(sampleCaption);

    // Analysis Results section
    const reportSection2 = document.createElement('div');
    reportSection2.className = 'report-section';
    reportSection2.style.cssText = 'margin-bottom: 30px;';
    
    const analysisResultsTitle = document.createElement('h2');
    analysisResultsTitle.innerText = 'Analysis Results';
    analysisResultsTitle.style.cssText = 'color: #333; border-bottom: 1px solid #ccc; padding-bottom: 5px;';
    
    const rockCharacteristicsP = document.createElement('p');
    rockCharacteristicsP.innerText = rockCharacteristics;
    rockCharacteristicsP.style.cssText = 'line-height: 1.6; margin-bottom: 15px;';
    
    const habitabilityAssessmentP = document.createElement('p');
    habitabilityAssessmentP.innerText = habitabilityAssessment;
    habitabilityAssessmentP.style.cssText = 'line-height: 1.6;';

    reportSection2.appendChild(analysisResultsTitle);
    reportSection2.appendChild(rockCharacteristicsP);
    reportSection2.appendChild(habitabilityAssessmentP);

    // Analyst Information section
    const reportSection3 = document.createElement('div');
    reportSection3.className = 'report-section';
    reportSection3.style.cssText = 'margin-bottom: 30px;';
    
    const analystInfoTitle = document.createElement('h2');
    analystInfoTitle.innerText = 'Analyst Information';
    analystInfoTitle.style.cssText = 'color: #333; border-bottom: 1px solid #ccc; padding-bottom: 5px;';
    
    const analystCommentP = document.createElement('p');
    analystCommentP.innerHTML = `<b>Analyst Comment: </b>${analystComment}`;
    analystCommentP.style.cssText = 'line-height: 1.6; margin-bottom: 15px;';
    
    const analystNameP = document.createElement('p');
    analystNameP.innerHTML = `<b>Analyst Name: </b>${analystName}`;
    analystNameP.style.cssText = 'line-height: 1.6;';

    reportSection3.appendChild(analystInfoTitle);
    reportSection3.appendChild(analystCommentP);
    reportSection3.appendChild(analystNameP);

    // Signature line section
    const signatureLine = document.createElement('div');
    signatureLine.className = 'signature-line';
    signatureLine.style.cssText = 'margin-top: 50px;';
    
    const signatureTitle = document.createElement('p');
    signatureTitle.innerText = 'Signature:';
    
    const signatureLineHr = document.createElement('hr');
    signatureLineHr.style.cssText = 'width: 300px; margin-left: 0;';
    
    signatureLine.appendChild(signatureTitle);
    signatureLine.appendChild(signatureLineHr);

    // Footer section
    const footer = document.createElement('footer');
    footer.innerHTML = 'Gale Crater Research Station, Latitude -5.4, Longitude 137.8, Mars. blazersteam@gmail.com';
    footer.style.cssText = 'text-align: center; margin-top: 50px; padding-top: 20px; border-top: 1px solid #ccc; font-size: 12px;';

    // Append all sections
    reportContainer.appendChild(letterhead);
    reportContainer.appendChild(reportSection1);
    reportContainer.appendChild(reportSection2);
    reportContainer.appendChild(reportSection3);
    reportContainer.appendChild(signatureLine);
    reportContainer.appendChild(footer);

    // Add to document body temporarily
    document.body.appendChild(reportContainer);

    // Convert image and generate PDF
    convertToBase64(analysisImageSrc).then(base64Image => {
        sampleImage.src = base64Image;

        html2canvas(reportContainer, { scale: 2 }).then(canvas => {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');

            const imgWidth = 210; // A4 width in mm
            const pageHeight = 295; // A4 height in mm
            const imgHeight = canvas.height * imgWidth / canvas.width;
            const heightLeft = imgHeight - pageHeight;

            let position = 0;

            pdf.addImage(canvas.toDataURL('image/jpeg'), 'JPEG', 0, position, imgWidth, imgHeight);

            if (heightLeft > 0) {
                pdf.addPage();
                pdf.addImage(canvas.toDataURL('image/jpeg'), 'JPEG', 0, -pageHeight, imgWidth, imgHeight);
            }

            pdf.save(`${imageNameInput}_Image_Analysis_Report.pdf`);
            document.body.removeChild(reportContainer);
        }).catch(error => {
            console.error("Error generating PDF:", error);
            document.body.removeChild(reportContainer);
        });
    }).catch(error => {
        console.error("Error converting image to Base64:", error);
        document.body.removeChild(reportContainer);
    });
  }

  function convertToBase64(url) {
      return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'Anonymous';
          img.src = url;
          img.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              const dataURL = canvas.toDataURL('image/jpeg');
              resolve(dataURL);
          };
          img.onerror = error => reject(error);
      });
  }

  // Keyboard controls for mission control
  document.addEventListener('keydown', function(event) {
      const modal = document.getElementById('roverControlModal');
      if (!modal || modal.style.display !== 'block') return;
      
      const shortcuts = ['w', 'a', 's', 'd', ' ', 'e', 'r', 't', 'escape'];
      if (shortcuts.includes(event.key.toLowerCase())) {
          event.preventDefault();
      }
      
      switch(event.key.toLowerCase()) {
          case 'w':
              if (roverController) roverController.sendCommand('move', 'forward');
              break;
          case 's':
              if (roverController) roverController.sendCommand('move', 'backward');
              break;
          case 'a':
              if (roverController) roverController.sendCommand('move', 'left');
              break;
          case 'd':
              if (roverController) roverController.sendCommand('move', 'right');
              break;
          case ' ':
              if (roverController) roverController.sendCommand('move', 'stop');
              break;
          case 'e':
              if (roverController) roverController.sendCommand('emergencyStop', 'true');
              break;
          case 'r':
              if (roverController) roverController.sendCommand('resetEmergency', 'true');
              break;
          case 't':
              if (roverController) roverController.takeScreenshot('Manual Keyboard');
              break;
          case 'escape':
              modal.style.display = 'none';
              if (roverController) roverController.stopObjectDetection();
              break;
      }
  });

  document.addEventListener('keyup', function(event) {
      const modal = document.getElementById('roverControlModal');
      if (!modal || modal.style.display !== 'block') return;
      
      const movementKeys = ['w', 'a', 's', 'd'];
      if (movementKeys.includes(event.key.toLowerCase())) {
          if (roverController) {
              roverController.sendCommand('move', 'stop');
          }
      }
  });

  // Initialize teachable machine model
  loadModel();

  // Health check for backend
  setTimeout(() => {
      if (roverController) {
          roverController.checkBackendHealth();
      }
  }, 5000);

  // Periodic health check every 30 seconds
  setInterval(() => {
      if (roverController) {
          roverController.checkBackendHealth();
      }
  }, 30000);

  // Connection monitoring
  setInterval(() => {
      if (roverController) {
          const cameraConnected = roverController.websockets.camera && 
                                roverController.websockets.camera.readyState === WebSocket.OPEN;
          const commandConnected = roverController.websockets.command && 
                                 roverController.websockets.command.readyState === WebSocket.OPEN;
          
          const overallConnected = cameraConnected && commandConnected;
          
          if (overallConnected !== roverController.connectionStatus) {
              roverController.updateConnectionStatus(overallConnected);
          }
      }
  }, 2000);

  // Export global functions
  window.roverController = roverController;
  window.takeScreenshot = function(objectDetected) {
      if (roverController) {
          roverController.takeScreenshot(objectDetected);
      }
  };

</script>

</body>
</html>